<Rat23F> -> <Opt Function Definitions> # <Opt Declaration List> <Statement List> #
Token:keyword   Lexeme:function
<Opt Function Definitions> -> <Function Definitions>
<Function Definitions> -> <Function> <Function Definitions>
<Function> -> function <Identifier> (<Opt Parameter List>) <Opt Declaration List> <Body>
Token:identifier   Lexeme:divide
<Identifier> -> divide
Token:separator   Lexeme:(
Token:identifier   Lexeme:num
<Opt Parameter List> -> <Parameter List>
<Parameter List> -> <Parameter>, <Parameter List>
<Parameter> -> <IDs> <Qualifier>
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>
<Identifier> -> val
Token:keyword   Lexeme:integer
<Qualifier> -> integer
Token:separator   Lexeme:,
Token:identifier   Lexeme:switch
<Parameter List> -> <Parameter>
<Parameter> -> <IDs> <Qualifier>
<IDs> -> <Identifier>
<Identifier> -> switch
Token:keyword   Lexeme:bool
<Qualifier> -> bool
Token:separator   Lexeme:)
Token:keyword   Lexeme:real
<Opt Declaration List> -> <Declaration List>
<Declaration List> -> <Declaration>;
<Declaration> -> <Qualifier> <IDs>
<Qualifier> -> real
Token:identifier   Lexeme:ans
<IDs> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:;
Token:separator   Lexeme:{
<Body> -> { <Statement List> }
Token:keyword   Lexeme:if
<Statement List> -> <Statement> <Statement List>
<Statement> -> <If>
<If> -> if ( <Condition> ) <Statement> else <Statement> endif
Token:separator   Lexeme:(
Token:identifier   Lexeme:switch
<Condition> -> <Expression> <Relop> <Expression>
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> switch
Token:operator   Lexeme:==
<Term Prime> -> ε
<Expression Prime> -> ε
<Relop> -> ==
Token:identifier   Lexeme:true
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> true
Token:separator   Lexeme:)
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:{
<Statement> -> <Compound>
<Compound> -> { <Statement List> }
Token:identifier   Lexeme:ans
<Statement List> -> <Statement>
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:identifier   Lexeme:num
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> num
Token:operator   Lexeme:/
<Term Prime> -> / <Factor> <Term Prime>
Token:identifier   Lexeme:val
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> val
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:keyword   Lexeme:else
Token:separator   Lexeme:{
<Statement> -> <Compound>
<Compound> -> { <Statement List> }
Token:identifier   Lexeme:ans
<Statement List> -> <Statement>
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:identifier   Lexeme:val
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> val
Token:operator   Lexeme:/
<Term Prime> -> / <Factor> <Term Prime>
Token:identifier   Lexeme:num
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> num
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:keyword   Lexeme:endif
Token:keyword   Lexeme:ret
<Statement List> -> <Statement>
<Statement> -> <Return>
<Return> -> ret <Expression>;
Token:identifier   Lexeme:ans
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:keyword   Lexeme:function
<Function Definitions -> <Function>
<Function> -> function <Identifier> (<Opt Parameter List>) <Opt Declaration List> <Body>
Token:identifier   Lexeme:multiply
<Identifier> -> multiply
Token:separator   Lexeme:(
Token:identifier   Lexeme:num
<Opt Parameter List> -> <Parameter List>
<Parameter List> -> <Parameter>, <Parameter List>
<Parameter> -> <IDs> <Qualifier>
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>
<Identifier> -> val
Token:keyword   Lexeme:integer
<Qualifier> -> integer
Token:separator   Lexeme:,
Token:identifier   Lexeme:switch
<Parameter List> -> <Parameter>
<Parameter> -> <IDs> <Qualifier>
<IDs> -> <Identifier>
<Identifier> -> switch
Token:keyword   Lexeme:bool
<Qualifier> -> bool
Token:separator   Lexeme:)
Token:keyword   Lexeme:integer
<Opt Declaration List> -> <Declaration List>
<Declaration List> -> <Declaration>;
<Declaration> -> <Qualifier> <IDs>
<Qualifier> -> integer
Token:identifier   Lexeme:ans
<IDs> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:;
Token:separator   Lexeme:{
<Body> -> { <Statement List> }
Token:keyword   Lexeme:if
<Statement List> -> <Statement> <Statement List>
<Statement> -> <If>
<If> -> if ( <Condition> ) <Statement> else <Statement> endif
Token:separator   Lexeme:(
Token:identifier   Lexeme:switch
<Condition> -> <Expression> <Relop> <Expression>
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> switch
Token:operator   Lexeme:==
<Term Prime> -> ε
<Expression Prime> -> ε
<Relop> -> ==
Token:identifier   Lexeme:true
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> true
Token:separator   Lexeme:)
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:{
<Statement> -> <Compound>
<Compound> -> { <Statement List> }
Token:identifier   Lexeme:ans
<Statement List> -> <Statement>
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:identifier   Lexeme:num
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> num
Token:operator   Lexeme:*
<Term Prime> -> * <Factor> <Term Prime>
Token:identifier   Lexeme:val
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> val
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:keyword   Lexeme:else
Token:identifier   Lexeme:ans
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:operator   Lexeme:-
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> - <Primary>
Token:int   Lexeme:3
<Primary> -> <Integer>
<Integer> -> 3
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:keyword   Lexeme:endif
Token:keyword   Lexeme:ret
<Statement List> -> <Statement>
<Statement> -> <Return>
<Return> -> ret <Expression>;
Token:identifier   Lexeme:ans
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:separator   Lexeme:#
Token:keyword   Lexeme:integer
<Opt Declaration List> -> <Declaration List>
<Declaration List> -> <Declaration>; <Declaration List>
<Declaration> -> <Qualifier> <IDs>
<Qualifier> -> integer
Token:identifier   Lexeme:num
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>
<Identifier> -> val
Token:separator   Lexeme:;
Token:keyword   Lexeme:bool
<Declaration List> -> <Declaration>; <Declaration List>
<Declaration> -> <Qualifier> <IDs>
<Qualifier> -> bool
Token:identifier   Lexeme:switch
<IDs> -> <Identifier>
<Identifier> -> switch
Token:separator   Lexeme:;
Token:keyword   Lexeme:real
<Declaration List> -> <Declaration>;
<Declaration> -> <Qualifier> <IDs>
<Qualifier> -> real
Token:identifier   Lexeme:ans
<IDs> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:;
Token:keyword   Lexeme:get
<Statement List> -> <Statement> <Statement List>
<Statement> -> <Scan>
<Scan> -> get ( <IDs> );
Token:separator   Lexeme:(
Token:identifier   Lexeme:num
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>, <IDs>
<Identifier> -> val
Token:separator   Lexeme:,
Token:identifier   Lexeme:switch
<IDs> -> <Identifier>
<Identifier> -> switch
Token:separator   Lexeme:)
Token:separator   Lexeme:;
Token:identifier   Lexeme:ans
<Statement List> -> <Statement> <Statement List>
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:identifier   Lexeme:divide
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier> ( <IDs> )
<Identifier> -> divide
Token:separator   Lexeme:(
Token:identifier   Lexeme:num
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>, <IDs>
<Identifier> -> val
Token:separator   Lexeme:,
Token:identifier   Lexeme:switch
<IDs> -> <Identifier>
<Identifier> -> switch
Token:separator   Lexeme:)
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:keyword   Lexeme:put
<Statement List> -> <Statement> <Statement List>
<Statement> -> <Print>
<Print> -> put ( <Expression> );
Token:separator   Lexeme:(
Token:identifier   Lexeme:ans
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:)
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:;
Token:identifier   Lexeme:ans
<Statement List> -> <Statement> <Statement List>
<Statement> -> <Assign>
<Assign> -> <Identifier> = <Expression>;
<Identifier> -> ans
Token:operator   Lexeme:=
Token:identifier   Lexeme:multiply
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier> ( <IDs> )
<Identifier> -> multiply
Token:separator   Lexeme:(
Token:identifier   Lexeme:num
<IDs> -> <Identifier>, <IDs>
<Identifier> -> num
Token:separator   Lexeme:,
Token:identifier   Lexeme:val
<IDs> -> <Identifier>, <IDs>
<Identifier> -> val
Token:separator   Lexeme:,
Token:identifier   Lexeme:switch
<IDs> -> <Identifier>
<Identifier> -> switch
Token:separator   Lexeme:)
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:keyword   Lexeme:if
<Statement List> -> <Statement>
<Statement> -> <If>
<If> -> if ( <Condition> ) <Statement> else <Statement> endif
Token:separator   Lexeme:(
Token:identifier   Lexeme:ans
<Condition> -> <Expression> <Relop> <Expression>
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> ans
Token:operator   Lexeme:==
<Term Prime> -> ε
<Expression Prime> -> ε
<Relop> -> ==
Token:operator   Lexeme:-
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> - <Primary>
Token:int   Lexeme:3
<Primary> -> <Integer>
<Integer> -> 3
Token:separator   Lexeme:)
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:{
<Statement> -> <Compound>
<Compound> -> { <Statement List> }
Token:keyword   Lexeme:ret
<Statement List> -> <Statement>
<Statement> -> <Return>
<Return> -> ret <Expression>;
Token:int   Lexeme:0
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Integer>
<Integer> -> 0
Token:separator   Lexeme:;
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:}
Token:keyword   Lexeme:else
Token:separator   Lexeme:{
<Statement> -> <Compound>
<Compound> -> { <Statement List> }
Token:keyword   Lexeme:put
<Statement List> -> <Statement>
<Statement> -> <Print>
<Print> -> put ( <Expression> );
Token:separator   Lexeme:(
Token:identifier   Lexeme:ans
<Expression> -> <Term> <Expression Prime>
<Term> -> <Factor> <Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
<Identifier> -> ans
Token:separator   Lexeme:)
<Term Prime> -> ε
<Expression Prime> -> ε
Token:separator   Lexeme:;
Token:separator   Lexeme:}
Token:keyword   Lexeme:endif
Token:separator   Lexeme:#
